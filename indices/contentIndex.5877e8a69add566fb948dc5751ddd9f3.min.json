{"/":{"title":"ðŸš€ Daniel's Vault","content":"\nWelcome to my vault! Here you can find all my notes, from my University courses, to my personal projects, and even some random stuff I find interesting\n\n### University\n- ðŸ’¾ [[notes/Sistemas Operativos]]\n- ðŸŽ² [[notes/Bases de Dados]]\n- ðŸ“¦ [[notes/Object Oriented Programming]]\n","lastmodified":"2023-03-28T18:29:50.038425807Z","tags":null},"/notes/Bases-de-Dados":{"title":"Bases de Dados","content":"\n## Aulas prÃ¡ticas\n1. Aula\n2. [[PL - 27 Feb]]","lastmodified":"2023-03-28T18:29:50.038425807Z","tags":null},"/notes/Bash-Scripting":{"title":"Bash Scripting","content":"\nBash Scripting is a powerfull tool to for the everyday programmer. Be it by creating configuration files or schedueling programs or whatever you want. \nJust like any other programming language, bash scripting follows a set of rules to create program understandable by the computer. \n\n### Defining variables\n```sh\n#! /bin/bash\n\ngreeting=Hello\nname=Tux\necho $greeting $name\n```\n\n### Numerical expressions\nNumerical expressions can also be calculated and stores this way:\n```sh\n#! /bin/bash\n\nvar=$((3+9))\necho $var\n```\n\nBut fractions don't work correctly this way. For decimal calculations we can use `bc` command to get the output to a particular number of decimal places. `bc` (Bash Calculator) is a command line calculator that supports calculations up to a certain number of decimal points.\n\n### Read user input\nIn bash we can take user input usind the `read` command\n```sh\nread variable_name\n```\n\nTo promt the user with a custom message, use the -p flag like this: `read -p \"Enter your age\" variable_name`\n\n### Numeric Comparison and Logical operators\n\n| Operation             | Syntax        |\n| --------------------- | ------------- |\n| Equality              | num1 -eq num2 |\n| Greater than equal to | num1 -ge num2 |\n| Greater than          | num1 -gt num2 |\n| Less than equal to    | num1 -le num2 |\n| Less than             | num1 -lt num2 |\n| Not equal to          | num1 -ne num2 |\n\n**Syntax**:\n```sh\nif [ conditions ]\n\tthen\n\t\tcommands\nfi\n```\n\nExample:\n```sh\n#! /bin/bash\n\nread -p \"X: \" x\nread -p \"Y: \" y\n\nif [ $x -gt $y]\n\tthen\n\t\techo X is greater than Y\nelif [ $x -lt $y]\n\tthen\n\t\techo X is less than Y\nelif [ $x -eq $y]\n\tthen\n\t\techo X is equal to Y\nfi\n```\n\nWe can also add AND `-a` and OR `-o` as well.\nThe bellow statement translates to: if `a` is greater than 40 and `b` is less than 6.\n`if [ $a -gt 40 -a $b -lt 6]`\n\n### Looping and skipping\nIn this example we will iterate 5 times:\n```sh\n#! /bin/bash\n\nfor i in {1..5}\ndo\n\techo $i\ndone\n```\n\nWe can also loop through strings as well\n\n```sh\n#! /bin/bash\n\nfor X in cyan magenta yellow\ndo\n\techo $X\ndone\n```\n\n**While loops** check for a condition and loop until the condition remains `true`. We need to provide counter statemant that increments the counter to control loop execution. \nIn the example bellow, `(( i += 1 ))` is the counter statement that increments the value of `i`.\n\nExample:\n```sh\n#! /bin/bash\ni=1\nwhile [[ $i -le 10 ]] ; do\n\techo \"$i\"\n\t (( i += 1 ))\ndone\n```\n\n### Arguments for scripts from the command line\nIt is also possible to five arguments to the script o execution. \n`$@` represents the position of the parameters, starting from one.\n\n```sh\n#! /bin/bash\n\nfor x in $@\ndo\n\techo \"Entered arg is $x\"\ndone\n```\n","lastmodified":"2023-03-28T18:29:50.038425807Z","tags":null},"/notes/C":{"title":"C","content":"\n[[printf() vs write()]]\n","lastmodified":"2023-03-28T18:29:50.038425807Z","tags":null},"/notes/Config-files":{"title":"Config files","content":"[[Elixir]]\n\n# config.exs\nThis file is typically used to store configuration values that are set once and do not change during the lifetime of the application. This values are common to the whole application and are cached for the lifetime of the application?\nThis file is only read at compile time.\n\n# runtime.exs\nFor runtime configuration, you can use the `config/runtime.ex` file. It is executed right before applications start in both Mix and releases.\nThis file is tipically used to store configuration values related to feature flags or other settings that can be toggled on or off during runtime?\nIt is also woth noting that the `runtime.exs` file is loaded after the `config.exs` file. This also means that this file is read everytime the project is started and not only when it's compiled like `config.exs`.\n\n# dev.exs\nThis file is used to configure the application for developing purposes. It offers features such as the `:debug` logging which allows for better and more verbose logging messages or configure the application to reload modules automatically when changes are made.\n\n# prod.exs\nThis file on the other hand is used to configure the application in the production environment. It includes settings that optimize the application for performance and reliabiliity. For example, you might set the logging level to `:info` or configure the server to use a different database or server. \n","lastmodified":"2023-03-28T18:29:50.038425807Z","tags":null},"/notes/Database-Indexes":{"title":"Database Indexes","content":"[[Databases]]\n\n## What is a database index\nIndexes are data structures that can increase a database's efficiency in accessing tabales. Indexes are not required, the database can function properly without them, but query response time can be slower.\n\nEvery index is associated with a table and has a key, which is formed by one or more table columns. When a query need to access a table that has an index, the database can decide to use the index to retrieve recors faster.\n\n## How does an Index work?\nFor example in a book index, we first search the index for the topic we want. We get the page number where that topic is found in the book, and we go to that page.\n\nNow, imagine you have a database which has a table called persons with id, frist_name, last_name and zip_code and colummns. If you wanted to get the id of a person with a specific last_name you would have to:\n```SQL\nSELECT ssn\nFROM persons\nWHERE last_name = 'Chernosky'\n```\nIn a table with millions of lines this would take a long time.\nTo get better performance we can apply aliasing.\n\n## How to add and Index to a table\nHere'se the SQL code to create such and index to the table __`persons`__ using the column `last_name`:\n```SQL\nCREATE INDEX 1x1_test ON persons ( last_name )\n```\nThe syntax for index creation is simple:\n+ The index name -\u003e `ix1_test`\n+ The associated table -\u003e `persons`\n+ The column to use as the index key (`last_name`)\n\nIf we would execute the query again it would look for the index instead of doing a full sequential scan.\n\n## How and Index works internally\nIn SQL databases, indexes are internally organized in the form of trees. Like actual trees, database indexes have many branch bifurcations, and individual records are represented by the leaves.\nThis tree is created when we run the command `CREATE INDEX` statement.\n\n\n# Disadvantages of database Indexes\nLet's go over some of the possible downsides of using too many databases secondary indexes.\n\n## Aditional storage\nThe first and perhaps the most obvious drawback of adding indexes is that they take up additional storage space. The exact amount of space dependes on the size of the table and the number of columns in the index, but it's usually a small percentage of the total size of the table. A basic index only needs to store the values of the indexed columns as well as a pointer to the row in the table.\n\nThis is important to consider if you have large datasets, as adding multiple indexes to a table can quickly use a significant amount of additional storage space.\n\n## Slower writes\nEverytime we want to add anything new to our table, a write, we also need to insert this new data into the Idexed data structure, therefore increasing the write time.\n\n## Conclusion\nIndexing is a good form of increasing query speed. But it should be well planned before hand otherwise the database will end up with a lot of Indexes draging the querying times.\n\n# Articles\n```embed\ntitle: 'What are the disadvantages of database indexes?'\nimage: 'https://planetscale.com/images/blog/content/disadvantages-of-database-indexes/downsides-of-indexes-social.png'\ndescription: 'Learn about some of the possible downsides of using database indexes and how to remove unused database indexes in MySQL.'\nurl: 'https://planetscale.com/blog/what-are-the-disadvantages-of-database-indexes'\n```\n\n","lastmodified":"2023-03-28T18:29:50.038425807Z","tags":null},"/notes/Databases":{"title":"Databases","content":"#SoftwareEngineering ","lastmodified":"2023-03-28T18:29:50.038425807Z","tags":null},"/notes/Dep.-Pedag%C3%B3gico":{"title":"Dep. PedagÃ³gico","content":"#CeSIUM \n\n# ReuniÃµes\n+ [[ReuniÃ£o - 26 Feb 2023]]\n","lastmodified":"2023-03-28T18:29:50.038425807Z","tags":null},"/notes/Direct-Execution":{"title":"Direct Execution","content":"We learned that processes run by time sharing the CPU. So we know that different processes are always running in the CPU and that raises some challenges. One of them being _performance_. Virtualization is a difficult thing to achieve but our computer handles it very well, how does it do that? The second question is about control. With so many processes running how can we controll all of them and make sure they don't break anything? Without control a process could run forever, so this topic is essential. \n\n## Limited Direct Execution\nThis first technique allows programs to run very fast, but has some limitations with it. \nAs the the name \"Direct Execution\" says, the program run directly on the CPU. When the OS wishes to start a program running, it creates an entry for process list, allocates some memory for it, loads the program into memory, sets up the stack, clears the the registers and executes it.\nThis sounds very simple but offers no control from part of the OS when the program is running. This allows the program to do whatever it wants. Plus this doesn't allow for the OS to controll the process running which doesn't help in the quest for virtualization. \n\n## Restricted operations\nThe hardware assists the OS by providing different modes of execution.\nIn **user mode**, applications do not have full access to hardware resources. \nIn **kernell mode**, the OS has access to the full resources of the machine. \n\nTo execute a system call, a program must execute a special **trap** instruction. This instructuion quickly jumps into the kernel, and once in kernel mode you can perform the system call, if allowed. When finished, the OS calls a **return-from-trap** instruction that returns to the user calling program. ","lastmodified":"2023-03-28T18:29:50.038425807Z","tags":null},"/notes/Ecto-Multi":{"title":"Ecto Multi","content":"\n","lastmodified":"2023-03-28T18:29:50.038425807Z","tags":null},"/notes/Elixir":{"title":"Elixir","content":"#SoftwareEngineering \n\n# Core Elixir\n[[Config files]]\n\n# Ecto\n[[Ecto Multi]]\n\n# Guardian\n","lastmodified":"2023-03-28T18:29:50.038425807Z","tags":null},"/notes/Erros":{"title":"Erros","content":"[[MNOnL]]\n\nEste capÃ­tulo Ã© referente aos erros induzidos pelos cÃ¡lculos da calculadora ou do computador, quando procedemos Ã  utlizaÃ§Ã£o dos mesmos. \n\nComo Ã© obvio, nÃ£o existem equipamentos de com uma precisÃ£o de 100%, sejam eles balanÃ§as, voltÃ­metros, amperÃ­metros, termÃ³metros,  barÃ³metros, etc. Desta forma qualquer dado de entrada contÃªm uma *imprecisÃ£o inerente*, isto Ã©, nÃ£o hÃ¡ como os evitar.  A isto chamamos __incerteza nos dados__. \n\nAssim como o computador nÃ£o tem bits infinitos para poder realizar os calculos de forma exata. Ou quando usamos o pi, nÃ£o sendo possÃ­vel utilizar todos os seus nÃºmeros, tendo de o arredondar. Desta forma, os erros de arredondamentos vÃ£o-se acumulando Ã  medida que realizamos os cÃ¡lculos, ampliando cada vez mais o nÃ­vel de incerteza nos resultados. Aqui jÃ¡ estamos a lidar com __erros de arredondamento__. \n\nMas tambÃ©m surgem erros de truncamento, sendo eles:\n+ na substituiÃ§Ã£o de um problema contÃ­nuo em um *discreto. \n+ na substituiÃ§Ã£o de um processo de calculo finito por um finito (*mÃ©todos iterativos*), pois como Ã© obvio, na prÃ¡tica nÃ£o Ã© possÃ­vel realizar cÃ¡lculos infinitos. \nComo por exemplo, quando se pretende calcular $e^x$ usando a expansÃ£o em sÃ©rie de Taylor da funÃ§Ã£o:\n\n$$e^x = 1 + x + \\frac{1}{2!}x^2 + \\frac{1}{3!}x^3 + \\frac{1}{3!}x^3 + ... + \\frac{1}{n!}x^n + ... +$$\nSe se usar apenas o *n* termos da sÃ©rie (se a \"truncarmos\" no *enÃ©simo* termo) obtÃ©m-se uma aproximaÃ§Ã£o de $e^x$.\n\n## Formato da vÃ­rgula flutuante\n$$fl(x) = \\pm0.d_1d_2...d_3 \\times b^e$$\n+ a mantissa Ã© o nÃºmero de dÃ­gitos significativos que define o comprimento da palavra *k. \n+ $b$ Ã© a base de representaÃ§Ã£o, tipo $10^3$\n+ $e$ Ã© o expoente\nSe $d_1 \\ne 0$ o formato diz-se *normalizado.  \n\n## Erro absoluto\nO erro absoluto representa o o valor de erro ou engano a medir algo.\nConsiderando $\\bar{x}$ Ã© o valor exato de um nÃºmero e $x$ o valor aproximado desse mesmo nÃºmero:\n+ $d_x = |\\bar{x} - x|$ -\u003e **erro absoluto** (desconhecido!), pois estamos a calcular o mÃ³dulo da diferenÃ§a entre o valor real e o valor estimado. \n+ $|\\bar{x} - x| \u003c \\delta$ -\u003e limite superior do erro absoluto, isto significa que estamos a estabelecer o limite superior do erro;\n+ $\\bar{x} \\in [x - \\delta_x, x+ \\delta_x]$ -\u003e intervalo de incerteza, este intervalo representa o espaÃ§o de valores onde o valor real pode estar contido. \n\n## Erro relativo\nO erro relativo compara o erro absoluto com o tamanho real do objeto medido. Para calcular o erro relativo, tambÃ©m Ã© preciso calcular o **erro absoluto**. \n+ $r_x = \\frac{|\\bar{x}-x|}{|\\bar{x}|}, \\bar{x} \\ne 0$  -\u003e **erro relativo** (desconhecido!)\n+ $r_x \\approx \\frac{|\\bar{x}-x|}{|\\bar{x}|}\\leq\\frac{\\delta_x}{|x|}$ (100%r_x - percentagem de erro)\nTal como podemos observar, o erro relativo Ã© calculado atravÃ©s da divisÃ£o entre o valor do erro absoluto pelo valor real do que estamos a medir. \n\n## Majorante de um erro\nAssociado a um nÃºmero $x$ estÃ¡ o limite superior do erros absoluto $\\delta_x$ que Ã© calculado pela metade da Ãºltima casa dÃ©cimal de $x$.  ","lastmodified":"2023-03-28T18:29:50.038425807Z","tags":null},"/notes/Ficha-1":{"title":"Ficha 1","content":"## Arrays em Java\nOs arrays em Java sÃ£o uma entidade para agregar entidades do mesmo tipo de dados.\nSobre este array podemos invocar mÃ©todos de Java que realizam operaÃ§Ãµes sobre este. \nEm java quando se tenta acessar um Ã­ndice do array que nÃ£o existe, este vai devolver um erro, ao invÃ©s de `NULL`.\n\n### ExercÃ­cio 1\n```java\npublic class Main {  \n    public static void main(String[] args) {  \n        Scanner scanner = new Scanner(System.in);  \n  \n        int [] aux = new int[5];  \n        int a0 = 0;  \n        int a1 = 0;  \n        int a2 = 0;  \n        int a3 = 0;  \n        int a4 = 0;  \n  \n        for(int j = 0; j \u003c 5; j++) {  \n            System.out.println(\"Insira um inteiro: \");  \n            aux[j] = scanner.nextInt();  \n        }  \n  \n  \n        for(int j = 0; j \u003c 5; j++) {  \n            System.out.println(\"\"+aux[j]);  \n        }  \n  \n        Ficha2 ficha = new Ficha2();  \n        ficha.setArray(aux);  \n  \n        ficha.doisIndices(0, 3);  \n        String aux2 = ficha.toString();  \n        System.out.println(aux2);  \n    }  \n}\n```\n```java\npublic class Ficha2 {  \n    private int [] array;  \n  \n    public Ficha2(){  \n        this.array = new int [5];  \n    }  \n  \n    public void setArray(int [] a) {  \n        this.array = a;  \n    }  \n  \n    public void doisIndices(int a, int b) {  \n        this.array = Arrays.copyOfRange(this.array, a, b);  \n    }  \n  \n    public String toString(){  \n        String aux = \"\";  \n  \n        for(int j = 0; j \u003c this.array.length; j++) {  \n            aux = aux + this.array[j];  \n        }  \n        return aux;  \n    }  \n}\n```\n","lastmodified":"2023-03-28T18:29:50.038425807Z","tags":null},"/notes/Git":{"title":"Git","content":"#SoftwareEngineering\n","lastmodified":"2023-03-28T18:29:50.038425807Z","tags":null},"/notes/Git-bissect-command":{"title":"Git bissect - command","content":"[[Git]]","lastmodified":"2023-03-28T18:29:50.038425807Z","tags":null},"/notes/Gui%C3%A3o-1-Acesso-a-ficheiros":{"title":"GuiÃ£o 1 - Acesso a ficheiros","content":"[[Sistemas Operativos]]\n\n__Descritor de Ficheiro__:\nDe forma simples, quando um ficheiro Ã© aberto, o sistema operativo cria uma entrada que representa esse mesmo ficheiro e guarda informaÃ§Ã£o sobre esse ficheiro aberto. Exemplificando, se se tiver 100 ficheiros abertos no sistema, entÃ£o irÃ¡ tambÃ©m haver 100 entradas. Este nÃºmero Ã© um inteiro nÃ£o negativo e designa-se por __descritor de ficheiro__. \nPara alÃ©m disto tambÃ©m existem descritores standard como:\n+ __Standard Input__ (valor inteiro 0)\n+ __Standard output__ (valor inteiro 1)\n+ __Standard error__ (valor inteiro 2)\n\n## Estruturas de Kernel\n\n##### Tabela de processos (TP)\nPor cada processo no computador existe a tabela designada em cima que guarda descritores de ficheiro abertos. Para saber quantos ficheiros abertos posso ter utiliza-se `ulimit -n`\n\n##### Tabela de ficheiros\nTabela partilhada pelo sistema operativo que guarda o modo de abertura e posiÃ§Ã£o de leitura/escrita de cada descritor.\n\n##### Virtual nodes (V-node)\nUm V-node Ã© uma estrutura usada para representar um ficheiros, diretorias, FIFO's, domain sockets, etc, num sistema de ficheiros do kernel que contÃ©m informaÃ§Ãµes sobre o seu tipo, permissÃµes, dono entre outros.\n\n##### Index node (I-node)\nÃ‰ uma estrutura usada pelo kernel para representar um ficheiro ou diretoria no sistema de ficheiros do SO onde sÃ£o guardados metadados/atributos dos ficheiros. Para alÃ©m disso tambÃ©m guarda a localizaÃ§Ã£o dos dados no recurso fÃ­sico de armazenamento. \n\n\u003e **Nota**:\n\u003e  Em sistemas Unix, os I-nodes servem tambÃ©m como v-nodes, nÃ£o havendo uma implementaÃ§Ã£o explÃ­cita para os Ãºltimos.\n\n![[Pasted image 20230223181013.png]]\n\n## Chamadas ao sistema\n```c\nint open(const char *path, int oflag [, mode]);\n```\nInicializa um descritor para um determinado ficheiro, devolvendo o descritor ou erro.\n* `path` - path do ficheiro a abrir\n* `oflag` - modo de abertura (O_RDONLY, O_WRONLY...)\n* `mode` - permissÃµes de acesso para O_CREAT (e.g. 0640  \nequivale a rw-r-----)\n\n```c\nssize_t read(int fildes, void *buf, size_t nbyte);\n```\nDevolve o nÃºmero de bytes lidos ou erro.\n+ **fildes** - descritor de ficheiro\n+ **buf** - buffer para onde conteÃºdo Ã© lido\n+ **nbyte** - nÃºmero max de bytes a ler\n\n```c\nssize_t write(int fildes, const void *buf, size_t nbyte);\n```\nDevolve o nÃºmero de bytes escritos ou erro.\n+ **fildes** - descritor de ficheiro\n+ **buf** - buffer com contÃºdo a escrever\n+ **nbyte** - nÃºmero max de bytes a ler\n\n```c\noff_t lseek(int fd, off_t offset, int whence);\n```\n`lseek()` is Ã© uma chamada ao sistema que Ã© usada para alterar o read/write pointer de um file descriptor.\n- **fd** - o file descriptor do pointer que vai ser movido\n- **offset** - o offset do pointer\n- **whence** - o mÃ©todo em que o offset vai ser interpretado (rela, absolute, etc.)\n- **return** - esta funÃ§Ã£o retorna o offset do pointer (em bytes) desde o inicio do ficheiro\n\n```c\nint close(int fildes);\n```\nApaga o descritor da tabela do processo.\nDevolve 0 caso a operaÃ§Ã£o seja executada com sucesso, -1 caso contrÃ¡rio.\n\nA cada operaÃ§Ã£o de leitura/escrita efetuada sobre o mesmo descritor, a posiÃ§Ã£o de ler/escrever Ã© atualizada consoante o nÃºmero de bytes efetivamente lidos/escritos.\n\n\u003e **Nota**: Cada chamada ao sistema tÃªm um custo elevado. Isto Ã© importante notar para usecases mais potentes.\n--- \n\n# ExercÃ­cios\n\n### ExercÃ­cio 1\nPara resolver este exercÃ­cio temos de fazer uma funÃ§Ã£o que recebe um file path para dois ficheiros e lÃª o seu conteÃºdo escrevendo-o no segundo ficheiro recebido.\n```c\nvoid cp(char *file1, char *file2){\n    // read file 1\n    int fd1 = open(file1, O_RDONLY);\n    // write file 2\n    int fd2 = open(file2, O_WRONLY | O_CREAT, 0666);\n\n    char buff[MAX_BUFFER];\n\n    int c;\n    while ((c = read(fd1, buff, MAX_BUFFER)) \u003e 0) {\n        write(fd2, buff, c);\n    }\n\n    close(fd1);\n    close(fd2);\n}\n```\n\n### ExercÃ­cio 2\n\n\n### ExercÃ­cio 3\n__`fd`__ -\u003e esta variÃ¡vel representa o file desecriptor, ou seja, o ficheiro que queremos ler\n__`line`__ -\u003e nesta varÃ­avel vamos guardar a linha lida\n__`size`__ -\u003e tamanho mÃ¡ximo de bytes que vamos ler e guardar na variÃ¡vel `line`\n\n```c\nint readch(int fd, char* buf) {\n    return read(fd, buf, 1);\n}\n\nssize_t readln(int fd, char* line, size_t size) {\n    int next_pos = 0;\n    int read_bytes = 0;\n\n    while (next_pos \u003c size \u0026\u0026 readch(fd, line + next_pos) \u003e 0) {\n        read_bytes++;\n\n        if (line[next_pos] == '\\n') {\n            break;\n        }\n\n        next_pos++;\n    }\n\n    return read_bytes;\n}\n```\n\n### ExercÃ­cio 4\nPara este exercÃ­cio temos de verificar se o Ãºltimo caracter do buffer Ã© um `\\n` caso contrÃ¡rio a funÃ§Ã£o irÃ¡ colocar enumeraÃ§Ãµes no meio de linhas.\n\n```c\nvoid nl() {\n    int line_counter = 0;\n    char buffer[MAX_BUFFER];\n    int bytes_read = 0;\n\tint is_newline = 1;\n\n    while ( (bytes_read = readln(STDIN_FILENO, buffer, MAX_BUFFER)) \u003e 0) {\n        char line_number[10] = \"\";\n        // nl skips empty lines\n        \n\t\t// estamos a verificar se a linha lida anteriormente \n\t\t// era maior que o tamanho mÃ¡ximo do buffer\n        if (is_newline \u0026\u0026 buffer[0] != '\\n') {\n            snprintf(line_number, 10, \"%d: \", line_counter);\n            write(STDOUT_FILENO, line_number, sizeof(line_number));\n            line_counter++;\n        }\n\n        write(STDOUT_FILENO, buffer, bytes_read);\n\n\t\t// caso o Ãºltimo caracter lido passa a flag para 0\n        if (buffer[bytes_read] != '\\n') {\n            is_newline = 0;\n        }\n        else {\n            is_newline = 1;\n        }\n    }\n}\n```\n\n\u003e **snprintf**:\n\u003e Formats and stores a series of characters and values in the array buffer;\n\u003e Accepts an argument `n` which indicates the maximum number of characters to be written in the buffer.\n\u003e Is used to redirect the output of `printf()` function onto a buffer.\n\u003e Returns the number of characters that were supposed to be written on to the buffer, so only when the returned value is non-negative and less than `n`, the string has been completely written as expected.\n\n\u003e **printf**:\n\u003e O `printf()` nÃ£o foi usado neste exercÃ­cio pois ele contÃ©m um mecanismo de buffering interno onde apenas para de escrever quando encontra um `/n` ou `/0` de forma a que possa quebrar o nosso programa.\n\nResumidamente o que estÃ¡ a ser feito, Ã© correr o `readln()` atÃ© que \n\n### ExercÃ­cio 5\nAssumindo a seguinte struct:\n```c\nstruct person {\n    char name[32];\n    int age;\n};\n\nint main(int argc, char *argv[]) {\n    // function that writes a struct to the binary_file and then reads it to the terminal\n    int struct_size = sizeof(struct person);\n    int fd = open(\"binary_file\", O_RDWR | O_CREAT, 0666);\n    int off = 0;\n    \n    /* if (argc != 4) { */\n    /*     printf(\"Usage: %s \u003cflag\u003e \u003cname\u003e \u003cage\u003e\\n\", argv[0]); */\n    /*     return 1; */\n    /* } */\n    \n    if (argv[1][1] == 'i') {\n        struct person new;\n        struct person p;\n        new.age = atoi(argv[3]);\n        strcpy(new.name, argv[2]);\n\n        lseek(fd, off, SEEK_CUR);\n\n        while (read(fd, \u0026p, struct_size) \u003e 0) {\n            off += struct_size;\n            lseek(fd, off, SEEK_CUR);\n        }\n\n        write(fd, \u0026new, struct_size);\n    }\n    else if (argv[1][1] == 'f') {\n        struct person p;\n        lseek(fd, off, SEEK_CUR);\n\n        while ( (read(fd, \u0026p, struct_size) \u003e 0) \u0026\u0026 (strcmp(p.name, argv[2]) != 0)) {\n            off += struct_size;\n            lseek(fd, off, SEEK_CUR);\n        }\n        if (strcmp(p.name, argv[2]) == 0)\n            printf(\"name: %s; age: %d;\\n\", p.name, p.age);\n        else\n            printf(\"Person not found.\\n\");\n    }\n    else if (argv[1][1] == 'u') {\n        struct person p;\n        struct person new;\n        lseek(fd, off, SEEK_CUR);\n\n        while ( (read(fd, \u0026p, struct_size) \u003e 0) \u0026\u0026 (strcmp(p.name, argv[2]) != 0)) {\n            off += struct_size;\n            lseek(fd, off, SEEK_CUR);\n        }\n\n        if (strcmp(p.name, argv[2]) == 0) {\n            new.age = atoi(argv[3]);\n            strcpy(new.name, argv[2]);\n            printf(\"name: %s; age: %d;\\n\", new.name, new.age);\n            write(fd, \u0026new, struct_size);\n        }\n        else\n         printf(\"Person not found.\\n\");\n    }\n    else if (argv[1][1] == 'p') {\n        struct person p;\n        lseek(fd, off, SEEK_CUR);\n\n        while ( (read(fd, \u0026p, struct_size) \u003e 0)) {\n            printf(\"name: %s; age: %d;\\n\", p.name, p.age);\n            off += struct_size;\n            lseek(fd, off, SEEK_CUR);\n        }\n    }\n        \n    close(fd);\n\n    return 0;\n}\n```","lastmodified":"2023-03-28T18:29:50.038425807Z","tags":null},"/notes/Gui%C3%A3o-2-Gest%C3%A3o-de-Processos":{"title":"GuiÃ£o 2 - GestÃ£o de Processos","content":"[[Sistemas Operativos]]\n\n### ExercÃ­cio 2\n```c\nint main() {\n    int pid = fork();\n    if (pid == 0) {\n        printf(\"child PID: %d\\nparent PID: %d\\n\", getpid(), getppid());\n    } else {\n        // parent\n        wait(NULL);\n    }\n}\n```\n\n`getppid()` retorna o identificador do processo pai.\n`getpid()` retorna o identificador do processo atual\n\n### ExercÃ­cio 3\n```c\nvoid pid_looper(int counter) {\n    int pid = fork();\n\n    if (pid == 0 \u0026\u0026 counter \u003e 0) {\n        printf(\"PPID: %d\\n\", getppid());\n        printf(\"PID: %d\\n\", getpid());\n        printf(\"\\n\");\n        pid_looper(counter - 1);\n    }\n    else {\n        wait(NULL);\n    }\n}\n\nint main() {\n    pid_looper(10);\n    return 0;\n}\n```","lastmodified":"2023-03-28T18:29:50.038425807Z","tags":null},"/notes/Internet-of-DevOps":{"title":"Internet of DevOps","content":"[[Redes de Computadores]]\n\n## Definition of DevOps\nDevOps is a methodology in the Software development and IT industry. Used as a set of practices and tools, DevOps integrates and automates the work of software development (Dev) and IT operations (Ops) as means for improving and shorthening the systems development life cycle.\nSome examples of widley known DevOps tools are:\n+ **Git** - this is perhaps the best and most widely known version control tool in a development environment;\n+ **Jenkins** - it's an open source automation server. It helps autmoate parts of the software development related to buildingm, testing and development, facilitating [[Continous Integration]]. \n\n## Project focus\nThe Internet of DevOps project is focused on the use and enhancement of DevOps within large organizations developing [[Telecom \u0026 CyberPhysical Systems (T-CPS)]]. DevOps is today a standard practice in IT systems but has been lacking behind in many T-CPS industries. The project had the ambition to provide DevOps solutions for these industries, thus addressing their specific requirements and pain-points.\nFurthermore, the project aims to develop DevOps tools encompassing visualization tools and dashboard that will allow for developers to get feedback on the software produced.\nFinally, the project will be demonstrated in real world environments of telecomunications and 5G,  to automotive industries, consumer eletronics, aerospace \u0026 defense industries etc","lastmodified":"2023-03-28T18:29:50.038425807Z","tags":null},"/notes/MNOnL":{"title":"MNOnL","content":"#University \n\n\n```embed\ntitle: 'Introduction to Non Linear Programming Problem'\nimage: 'https://img.youtube.com/vi/JRWfph5PD7E/maxresdefault.jpg'\ndescription: ''\nurl: 'https://www.youtube.com/watch?v=JRWfph5PD7E'\n```\n\n\n","lastmodified":"2023-03-28T18:29:50.038425807Z","tags":null},"/notes/Object-Oriented-Programming":{"title":"ProgramaÃ§Ã£o Orientada a Objetos","content":"\n## Aulas PL\n1. [[Ficha 1]]\n","lastmodified":"2023-03-28T18:29:50.038425807Z","tags":null},"/notes/PL-27-Feb":{"title":"PL - 27 Feb","content":"# ContextualizaÃ§Ã£o e FundamentaÃ§Ã£o\n","lastmodified":"2023-03-28T18:29:50.038425807Z","tags":null},"/notes/Process-API":{"title":"Process API","content":"UNIX systems offer nit systems calls to interact with processes. Here we'll talk a bit about them.\n\n## The `fork()` system call\nThe `fork()` system call is a way to create a new proceess almost identicall to the process it was called from. When you call `fork()` it's almost like a new program just started running from the point you called the systems function. That way if we have this piece of code:\n```c\n#include \u003cstdio.h\u003e  \n#include \u003cstdlib.h\u003e  \n#include \u003cunistd.h\u003e  \n \nint main(int argc, char *argv[]) {  \n\tprintf(\"hello world (pid:%d)\\n\", (int) getpid());  \n\tint rc = fork();  \n\tif (rc \u003c 0) {  \n\t\t// fork failed  \n\t\t fprintf(stderr, \"fork failed\\n\");  \n\t\t exit(1);  \n\t } else if (rc == 0) {  \n\t\t // child (new process)  \n\t\t printf(\"hello, I am child (pid:%d)\\n\", (int) getpid());  \n\t } else {  \n\t\t // parent goes down this path (main)  \n\t\t printf(\"hello, I am parent of %d (pid:%d)\\n\",  \n\t\t rc, (int) getpid());  \n\t }  \n return 0;  \n }\n```\nThe output may be this:\n```sh\nprompt\u003e ./p1  \nhello world (pid:29146)  \nhello, I am parent of 29147 (pid:29146)  \nhello, I am child (pid:29147)  \nprompt\u003e\n```\n\nNotice how the child didn't start running from the beginning of the `main()` function. \n\n## The `wait()` system call\n\nSometimes you need to wait for a process to finish running. For this matter you can use the `wait()` system call (or it's more complete sibling `waitpid()`).\nLook at this example:\n```c\n#include \u003cstdio.h\u003e  \n#include \u003cstdlib.h\u003e  \n#include \u003cunistd.h\u003e  \n \nint main(int argc, char *argv[]) {  \n\tprintf(\"hello world (pid:%d)\\n\", (int) getpid());  \n\tint rc = fork();  \n\tif (rc \u003c 0) {  \n\t\t// fork failed  \n\t\tfprintf(stderr, \"fork failed\\n\");  \n\t\texit(1);  \n\t } else if (rc == 0) {  \n\t\t// child (new process)  \n\t\tprintf(\"hello, I am child (pid:%d)\\n\", (int) getpid());  \n\t } else {  \n\t\t// parent goes down this path (main)  \n\t\tint rc_wait = wait(NULL);\n\t\tprintf(\"hello, I am parent of %d (pid:%d)\\n\",  \n\t\trc, (int) getpid());  \n\t }  \n return 0;  \n }\n```\nThe output is:\n``` sh\nprompt\u003e ./p1  \nhello world (pid:29146)  \nhello, I am child (pid:29147)  \nhello, I am parent of 29147 (pid:29146)  \nprompt\u003e\n```\nThis example is quite similar to the one above, but it isn't. This example is *deterministic* which means that the output order in this one is always going to be the same because of the `wait()` system call which tells the parent process to wait for the child process and only after it can proceede. \n\n\n## The `exec()` system call\n\nThe `exec()` system call is a bit more difficult to understand than the other ones. Whenever you call this system call, you're switching the program running in the current process for another one. Here is an example:\n```c\n#include \u003cstdio.h\u003e  \n#include \u003cstdlib.h\u003e  \n#include \u003cunistd.h\u003e  \n \nint main(int argc, char *argv[]) {  \n\tprintf(\"hello world (pid:%d)\\n\", (int) getpid());  \n\tint rc = fork();  \n\tif (rc \u003c 0) {  \n\t\t// fork failed  \n\t\tfprintf(stderr, \"fork failed\\n\");  \n\t\texit(1);  \n\t } else if (rc == 0) {  \n\t\t// child (new process)  \n\t\tprintf(\"hello, I am child (pid:%d)\\n\", (int) getpid());  \n\t\tchar *myargs[3];\n\t\tmyargs[0] = strdup(\"wc\");\n\t\tmyargs[1] = strdup(\"p3.c\");\n\t\tmyargs[2] = NULL;\n\t\texecvp(myargs[0], myargs); //this is the exec() system call\n\t\tprintf(\"this shouldn't print out\");\n\t } else {  \n\t\t// parent goes down this path (main)  \n\t\tint rc_wait = wait(NULL);\n\t\tprintf(\"hello, I am parent of %d (rc_wait:%d) (pid:%d)\\n\",\n\t\t\trc, rc_wait, (int) getpid()); \n\t }  \n return 0;  \n }\n```\nAnd this should return:\n```sh\nprompt\u003e ./p1  \nhello world (pid:29383) \nhello, I am child (pid:29384) \n\t29  107  1030 p3.c\nhello, I am parent of 29384 (rc_wait:29384) (pid:29383) \nprompt\u003e\n```\nAs you can see, the \"this shouldn't print out\" didn't in fact print out. That's because the `exec()` system call made the current process run another program and leave this one. \n\nThe separation of the `exec()` and `fork()` system calls are essential to achieve a variety of things because it lets the shell run code _after_ a fork() but _before_ the call to exec().\n\n\u003e **Note:\n\u003e There are many different `exec()` system calls. Read the man pages to learn more.\n\n\n## The `kill()` system call\n\n```c\nint kill(pid_t** _pid_**, int** _sig_**);**\n```\nBeyond `fork()`, `exec()` and `wait()`, there are a lot of other interfaces for interacting with processes in UNIX systems. For example the `kill()` system call, which can be used to send a signal to any process or process group. This signals are used everywhere, and usually a certain keyboard stroke is a key to send a signal. For example in your terminal, you can send a signal to stop the program running with ctrl+c. That's because your shell terminal uses processes in order to work.\nIf the _pid_ is positive, then the signal _sig_ is sent to the process with the ID specified by _pid_. \nIf the _pid_ equals 0, then _sig_ is sent to every process in the group of the calling process. \nIf the _pid_ equals -1, then the _sig_ is sent to every process for which the process calling process has permission to send signals, except for process 1 (**init**)\nIf the _pid_ is less than -1, then _sig_ is sent to every process in the process group whose is **-pid**.","lastmodified":"2023-03-28T18:29:50.038425807Z","tags":null},"/notes/Processes":{"title":"Processes","content":"## What is a Process?\nWhen running a program, that program is going to be processed by the CPU. But, if a program had to wait for the previous program to finish what its doing, then that would make the computer very slow. A way around this is by **virtualization**, where various programs are sharing the same resources, and by resource I mean the CPU. With this, a bunch of *processes* can be running at the \"same\" time. \nIn fact it is not running at the same time, but in different chunks of time. This method is called **time sharing**.\n\n\u003e **time sharing**:\n\u003e is a basic technique used by an OS to share a resource. By allowing the resource to be used for a little while by one entity, and then a little while by another, and so forth, the resource in question (e.g., the CPU, or a network link) can be shared by many. The counterpart of time sharing is space sharing, where a resource is divided (in space) among those who wish to use it. For example, disk space is naturally a space-shared resource; once a block is assigned to a file, it is normally not assigned to another file until the user deletes the original file.\n\n## How to controll it\nAs you can imagine, all operating Systems nowadays offer a Process API, where we can take advantage of this technics used by the CPU. This are some basic API's:\n+ **Create**: An operating system must have this option available. Whenever you start a new program, or open any app on your computer, the OS is invoked to create a new process.\n+ **Destroy**: If we have an option to create a process, we should also have an option to kill it. Most programs exit themselves when finished, however, for some reason whe should be able to kill a process.\n+ **Wait**: Sometimes we need to wait for a process to finish what its doing. Imagine we want to wait for its result in order to proceede to somehting else, we would need to wait. \n\nThere are many more API's available to controll and manage processes, these are some of the most basic ones. \n\n## Creating processes in a little more detail\nThe first thing the OS needs to do in order to start a process it to load a program that resides in the disk, into memory.\nOnce loaded into memory, the OS needs to alocate space for the program stack and the heap.\nThe OS will also do some other initialization taks for the I/O. For example, in UNIX systems, each process has three *file descriptors*, for _standard input_, _output_, and _error_.\n\n## Process states\nWhen running processes can have many states. Those being:\n- **Running**: The process is running on the processor. Which means it is executing the instructions. \n- **Ready**: When in this state, the process is ready to run, but it's not running yet. This may happen when a process is waiting for another one to finish in order to start. \n- **Blocked**: Sometimes we need to block processes to allow other processes to run in order to keep going. Imagine we have a process running and initiates and I/O operation, since that will take some time, it becomes blocked, allowing other processes to go. \n\n## OS data structures\nAs any other program, the OS needs some data structures for it to work, since the OS is also a program. So the OS stores all the process and states happening, in some file in the kernell. It will also store information such as the CPU registers state, so for when a process is blocked, for example, when it returns to what it was doing, it knows how to restore the data in the physical registers. This is known as **context switching**. \n\n\u003e **Process List**:\n\u003e Operating systems are replete with various important data structures that we will discuss in these notes. The process list (also called the task list) is the first such structure. It is one of the simpler ones, but certainly any OS that has the ability to run multiple programs at once will have something akin to this structure in order to keep track of all the running programs in the system. Sometimes people refer to the individual structure that stores information about a process as a Process Control Block (PCB), a fancy way of talking about a C structure that contains information about each process (also sometimes called a process descriptor).\n","lastmodified":"2023-03-28T18:29:50.038425807Z","tags":null},"/notes/React":{"title":"React","content":"#SoftwareEngineering \n\n# Basic concepts\n[[React DOM]]\n\n\n# Articles\n\n```embed\ntitle: 'Authentication with React.js'\nimage: 'https://res.cloudinary.com/practicaldev/image/fetch/s--sEdT27Mp--/c_imagga_scale,f_auto,fl_progressive,h_500,q_auto,w_1000/https://thepracticaldev.s3.amazonaws.com/i/dtuhjpksglp13pj2xoip.png'\ndescription: 'In todayâ€™s article, I will show you how to create the front end part of user authentication with React.js.'\nurl: 'https://dev.to/ksushiva/authentication-with-react-js-9e4'\n```\n\n","lastmodified":"2023-03-28T18:29:50.038425807Z","tags":null},"/notes/React-DOM":{"title":"React DOM","content":"\n\n## What is it DOM?\nDOM stands for *Documents Object Model* and in simple words is the structural representation of the UI of a web app in a tree form with all its components associated as branches of the tree. \nEvery bit of html tag that you create is added to this tree allowing for the JavaScript to access it and modify their attributes, styles and other properties. \nThis allows for JavaScript ot quickly alter a website UI. \n\n## What is React DOM?\nReact introduces the concept of Virtual DOM, which is a lightweight replica of the real DOM kept by React. \nDOM manipulation takes time, but React DOM manipulation is very lightweight allowing for quick manipulation.\nWhenever the state of any component is updated, the virtual DOM is reconstructed. ","lastmodified":"2023-03-28T18:29:50.038425807Z","tags":null},"/notes/Redes-de-Computadores":{"title":"Redes de Computadores","content":"\n### Projeto 1\nGrupo: Eu, Pedro Sousa, Filipe Pereira\nResearch: [[Internet of DevOps]]\n\n# Computer Networking A Top-Down Approach\n\n## Computer Networks and the Internet\n1. [[What is the Internet?]]\n2. [[The Network Edge]]\n","lastmodified":"2023-03-28T18:29:50.038425807Z","tags":null},"/notes/Reuni%C3%A3o-26-Feb-2023":{"title":"ReuniÃ£o - 26 Feb 2023","content":"# Objetivos\nNesta reuniÃ£o temos como objetivo distribuir as atividades pelos colaboradores dando-lhes mais espaÃ§o para trabalharem sobre elas.\nAs atividades a serem distribuidas nesta sessÃ£o sÃ£o:\n1. Workshop de UX/UI (onde eu vou estar a liderar)\n2. EstÃ¡gios de VerÃ£o (liderada pelo Pedro)\n3. Language show-off de C e Java (liderada pelo Garfield)\n","lastmodified":"2023-03-28T18:29:50.038425807Z","tags":null},"/notes/Sistemas-Operativos":{"title":"Sistemas Operativos","content":"\n## GuiÃµes das aulas\n1. [[GuiÃ£o 1 - Acesso a ficheiros]]\n2. [[GuiÃ£o 2 - GestÃ£o de Processos]] \n3. \n\n## Bibliografia opcional\n[[Three Easy Pieces]]","lastmodified":"2023-03-28T18:29:50.038425807Z","tags":null},"/notes/Summer-Camp-2023":{"title":"Summer Camp 2023","content":"#CeSIUM\nData prevista para realizar o Summer Camp: 1Ëš semana de Julho;\nData prevista de tÃ©rmino: 1Ëš semana de Agosto;\n\n## Brainstorm\n+ Fazer uma mini-apresentaÃ§Ã£o semanal do trabalho desenvolvido\n+ Fazer documentaÃ§Ã£o dos repositÃ³rios sujeitos ao summer camp\n+ Possibilidade de termos uma equipa de UX/UI\n+ Atividades lÃºdicas pelo meno 1x por semana\n+ Manter as talks/workshops\n+ Criar o plano de talks para o Summer Camp\n+ Possibilidade de manter o formato de envio de CV's\n+ Fornecer certificados para os participantes\n+ Organizar mini-hackathons durante o summer camp\n+ Dar mini prÃ©mio Ã  \"Equipa da semana\", onde durante os 4 dias de trabalho dessa semana Ã© avaliado a equipa que desenvolveu melhores features ou improvements nos respetivos projetos. \n\n## Programa\nSpreadsheet: https://docs.google.com/spreadsheets/d/1RqUncsVQL00TRxgf2qjbubahWWLZBk6Yz70hj5NxCcg/edit#gid=0\n\n\n### Workshop de seguranÃ§a\n\n### Workshop de documentaÃ§Ã£o\norador: Paula Vaz\ndia: 17 de Julho, 2023\nhora: 14:00 -\u003e 16:00\n\n### Workshop HTML + tailwind\n\n","lastmodified":"2023-03-28T18:29:50.038425807Z","tags":null},"/notes/Telecom-CyberPhysical-Systems-T-CPS":{"title":"Telecom \u0026 CyberPhysical Systems (T-CPS)","content":"This is basically two different concepts unified as one:\n+ Telecom (Telecommunications network) is a group of nodes interconnected by telecommunications links that are used to exchange messages between the nodes. The links may use a variety of technologies of circuit switching, message switching or package switching to pass messages and signals.\n+ A cyber-physical system is a computer system in which a mechanism is controlled or monitored by computer-based algorithms. In cyber-physical systems, physical and software components arfe deeply interwined, able to operate on different spatial and temporal scales. \n\n### Examples\nExamples of CPS include smart grid, autonomous automobile systems, medical monitoring, industrial control systems, robotics systems and automatic pilot avionics. ","lastmodified":"2023-03-28T18:29:50.038425807Z","tags":null},"/notes/The-Network-Edge":{"title":"The Network Edge","content":"## Access Networks\n\n### Digital Subscriber Line (DSL)\nToda, the two most prevalent types of broadband residential access are **Digitial Subscriber Line (DSL)** and cable. A residence typically obtains DSL INternet acess from the same local telephone company taht provides its wired local phone access. Thus, when DSL is used, a customer's telco is also its **ISP**. \n\nDSL is the primary form of broadband internet access and uses exisitng telephone wiring to transmit data via a DSL modem. The data over DSL phone line goes to internet and the voice over DSL phone line goes to telephone net. \n\nISP stands for _Internet Service Provider_ which is a company that provides companies and individuals the access to the internet. \n\n### Cable Network\nWhen we transmit a bit through the network, that bit is going to get kicked around and transmitted many times. These bit passed by many **physical medium** in order to get to its destiny. \nTherefore, as you can imagine there are many media types that let us transmit information. And this medium can take many shapes and forms and does not have to take the same type throught all of the transmition of one packet. \n\nSome of these mediums are:\n\n#### Twisted-Pair Copper Wire\nThis is the least expensive and most used guided transmition medium. It consists of two insulated copper wires, each about 1mm thick, arranged in a regular spiral pattern. The wires are twisted together in order to reduce eletrical interference. \n\n#### Coaxial Cable\nLike the twisted pair, coaxial cable consists of two copper conductors, but the two conductors are concentruc rather than parallel. This allows the cable to achieve high data transmition rates.\nThis type of cable is quite common in cable television systems. \n\n#### Fiber Optics\nAn optical fiber is a thin, flexible medium that conductes pulses of light, with each pulse representing a bit. A single optical fiber cable can support tremendious bit rates. \nFiber optics is also immune to electromagnetic interference, have a very low signal attenuation up to 100 km and are very hard to tap. \n\n#### Terrestral Radio Channels\nRadio Channels carry signals in the electromagnetic spectrum. They are an attractive medium because they require no physical wire to be installed, can penetrate walls, provide connectivity to a mobile user, and can potentially carry a signal for ling distances. \n\n#### Satellite Radio Channels\nA communication satellite links two or more Earth-based microwave transmitter/receivers, known as ground stations. \n","lastmodified":"2023-03-28T18:29:50.038425807Z","tags":null},"/notes/Three-Easy-Pieces":{"title":"Three Easy Pieces","content":"#books \n\n### Virtualization\n1. [[Processes]]\n2. [[Process API]]\n3. [[Direct Execution]]\n\n### Concurrency\n\n### Persistence","lastmodified":"2023-03-28T18:29:50.038425807Z","tags":null},"/notes/Vim":{"title":"Vim","content":"#SoftwareEngineering \n\n\n# Articles\n```embed\ntitle: 'Find anything you need with fzf, the Linux fuzzy finder tool'\nimage: 'https://www.redhat.com/sysadmin/sites/default/files/styles/google_discover/public/2019-09/binoculars-blur-close-up.jpg?itok=eq4Y9AAz'\ndescription: 'Iâ€™m thankful for the Linux fuzzy finder tool because it superpowers the command line by making it fast to find whatever Iâ€™m looking for.'\nurl: 'https://www.redhat.com/sysadmin/fzf-linux-fuzzy-finder'\n```\n\n```embed\ntitle: 'Search and Replace in Vim'\nimage: 'https://www.baeldung.com/wp-content/uploads/sites/2/2021/09/Featured-Linux-6.png'\ndescription: 'Explore the different methods available for performing a search and replace with the Vim editor.'\nurl: 'https://www.baeldung.com/linux/vim-search-replace'\n```\n","lastmodified":"2023-03-28T18:29:50.038425807Z","tags":null},"/notes/What-is-the-Internet":{"title":"What is the Internet?","content":"## What is the Internet?\nVery basically, the internet is a connection of computing devices throughout the world, that connect *end systems* together like the common computer in your house. These *end systems* or *hosts* may have running apps that require access to the network and communicate with the exterior by it. \nThe *communication links* are what connects theese end systems together and they my consist of fiber, copper, radio or even satellite. \n*Packet Switches* are the ones responsible to redirect our data in the correct way, so it arrives at its intended destination. A packet my travel through more than one packet switch/router. \n\nBut overall, the internet is a _network of networks_ that communicates through *protocols*.\n\n## What is a protocol?\nAll activities through the network that envolve two or more computers, may be considered a protocol. Every time you want to communicate with other computer, you must do it via a protocol. \nSo see as a set of regulations that you want to follow in order to speak with a computer. In order for two computers to communicate. \nThese protocols are agreed standards used in communications and they are vital in communications. \n\n","lastmodified":"2023-03-28T18:29:50.038425807Z","tags":null},"/notes/docker":{"title":"docker","content":"#SoftwareEngineering \n\n# Articles\n\n```embed\ntitle: 'you need to learn Docker RIGHT NOW!! // Docker Containers 101'\nimage: 'https://img.youtube.com/vi/eGz9DS-aIeY/maxresdefault.jpg'\ndescription: ''\nurl: 'https://www.youtube.com/watch?v=eGz9DS-aIeY'\n```\n\n```embed\ntitle: 'Docker Compose will BLOW your MIND!! (a tutorial)'\nimage: 'https://img.youtube.com/vi/DM65_JyGxCo/maxresdefault.jpg'\ndescription: ''\nurl: 'https://www.youtube.com/watch?v=DM65_JyGxCo'\n```","lastmodified":"2023-03-28T18:29:50.038425807Z","tags":null},"/notes/printf-vs-write":{"title":"printf() vs write()","content":"[[C]]\n\nThe first big difference between these two is that `write()` is a system call and `printf()` is a C function. A system call is a function provided by the kernell and write is just a regular C library function.\n\nThe other big difference between these two is that `write()` is *only* meant to write a sequence of bytes.\nOn the other hand, `printf()` allows you to ouptut your data into a formated sequence of bytes and then calls `write()` to print those bytes. ","lastmodified":"2023-03-28T18:29:50.038425807Z","tags":null}}